/**
 * Unified Battle Screen Component
 * Works on both Horizon and Web platforms
 * Exactly mimics the UI from deployments/web/src/screens/battleScreen.ts
 */

import { View, Text, Image, Pressable, Binding } from '../index';
import { COLORS } from '../../../shared/styles/colors';
import { DIMENSIONS, GAPS } from '../../../shared/styles/dimensions';
import {
  standardCardDimensions,
  buffCardDimensions,
  trapCardDimensions,
  habitatShiftCardDimensions,
  sideMenuButtonDimensions,
  gameDimensions
} from '../../../shared/constants/dimensions';
import {
  battleBoardAssetPositions,
  playboardImagePositions,
  sideMenuPositions
} from '../../../shared/constants/positions';
import { nectarEmoji, deckEmoji } from '../../../shared/constants/emojis';
import type { BattleDisplay, ObjectiveDisplay } from '../../../bloombeasts/gameManager';
import { UINodeType } from './ScreenUtils';
import { createSideMenu, createTextRow } from './common/SideMenu';
import { createCardComponent, CARD_DIMENSIONS } from './common/CardRenderer';
import { createCardDetailPopup } from './common/CardDetailPopup';

export interface BattleScreenProps {
  battleState?: any; // Can be BindingInterface<string> OR BindingInterface<BattleDisplay>
  message?: any; // BindingInterface<string> for simple messages
  battleDisplay?: any; // Direct BattleDisplay binding for full battle data
  onAction?: (action: string) => void;
  onNavigate?: (screen: string) => void;
  onRenderNeeded?: () => void;
}

/**
 * Unified Battle Screen that exactly replicates web deployment's battle UI
 */
export class BattleScreen {
  // State bindings
  private battleState: any; // Simple string state
  private message: any; // Simple message
  private battleDisplay: any; // Full BattleDisplay binding
  private showHand = new Binding(true);
  private handScrollOffset = new Binding(0);
  private turnTimer = new Binding(60);
  private selectedCardDetail = new Binding<any | null>(null);

  // Timer management
  private timerInterval: NodeJS.Timeout | null = null;

  // Configuration
  private cardsPerRow = 5;
  private rowsPerPage = 1;

  // Callbacks
  private onAction?: (action: string) => void;
  private onNavigate?: (screen: string) => void;
  private onRenderNeeded?: () => void;

  constructor(props: BattleScreenProps) {
    // Handle both simple and full battle modes
    this.battleState = props.battleState;
    this.message = props.message;
    this.battleDisplay = props.battleDisplay;

    this.onAction = props.onAction;
    this.onNavigate = props.onNavigate;
    this.onRenderNeeded = props.onRenderNeeded;

    // Subscribe to state changes that need re-rendering
    this.showHand.subscribe(() => this.onRenderNeeded?.());
    this.handScrollOffset.subscribe(() => this.onRenderNeeded?.());
    this.selectedCardDetail.subscribe(() => this.onRenderNeeded?.());

    // Start turn timer if it's player's turn (full mode)
    if (this.battleDisplay) {
      const state = this.battleDisplay.get();
      if (state && state.turnPlayer === 'player') {
        this.startTurnTimer();
      }
    }
  }

  /**
   * Create the complete battle UI
   */
  createUI(): UINodeType {
    console.log('[BattleScreen] createUI called');
    // Check if we have full battle display data
    if (this.battleDisplay) {
      const state = this.battleDisplay.get();
      console.log('[BattleScreen] Battle display state:', state ? 'Present' : 'Null');
      if (!state) {
        console.log('[BattleScreen] No battle display data, showing loading state');
        return this.createLoadingState();
      }

      console.log('[BattleScreen] Creating full battle UI with data:', {
        playerHealth: state.playerHealth,
        opponentHealth: state.opponentHealth,
        currentTurn: state.currentTurn
      });
      // Full battle UI
      return View({
        style: {
          width: gameDimensions.panelWidth,
          height: gameDimensions.panelHeight,
          position: 'relative',
          overflow: 'hidden',
        },
        children: [
          // Layer 1: Background image (full screen)
          this.createBackground(),

          // Layer 2: Playboard overlay
          this.createPlayboard(),

          // Layer 3: Battle zones (beasts, traps, buffs, habitat)
          this.createBattleZones(state),

          // Layer 4: Player/Opponent info displays
          this.createInfoDisplays(state),

          // Layer 5: Side menu with controls
          this.createBattleSideMenu(state),

          // Layer 6: Player hand overlay (conditionally shown)
          this.createPlayerHand(state),

          // Layer 7: Card detail popup (if active)
          state.cardPopup ? this.createCardPopup(state.cardPopup) : null,

          // Layer 8: Attack animation overlays
          this.createAttackAnimations(state),
        ].filter(Boolean),
      });
    }

    // Simple placeholder mode (for compatibility with BloomBeastsGame)
    console.log('[BattleScreen] No battleDisplay binding, using simple mode');
    return this.createSimpleBattleUI();
  }

  /**
   * Create simple battle UI (placeholder mode for BloomBeastsGame compatibility)
   */
  private createSimpleBattleUI(): UINodeType {
    const battleState = this.battleState?.get() || 'initializing';
    const message = this.message?.get() || 'Preparing for battle...';

    return View({
      style: {
        width: DIMENSIONS.panel.width,
        height: DIMENSIONS.panel.height,
        backgroundColor: COLORS.background,
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 40
      },
      children: [
        // Battle title
        Text({
          content: '‚öîÔ∏è Battle Arena ‚öîÔ∏è',
          style: {
            fontSize: DIMENSIONS.fontSize.hero,
            fontWeight: 'bold',
            color: COLORS.textPrimary,
            marginBottom: 30
          }
        }),

        // Battle state
        View({
          style: {
            backgroundColor: COLORS.surface,
            borderRadius: 12,
            padding: 30,
            marginBottom: 30,
            minWidth: 400,
            alignItems: 'center'
          },
          children: [
            Text({
              content: battleState,
              style: {
                fontSize: DIMENSIONS.fontSize.xl,
                fontWeight: 'bold',
                color: COLORS.warning,
                marginBottom: 10,
                textTransform: 'uppercase'
              }
            }),
            Text({
              content: message,
              style: {
                fontSize: DIMENSIONS.fontSize.lg,
                color: COLORS.textSecondary,
                textAlign: 'center'
              }
            })
          ]
        }),

        // Action buttons
        View({
          style: {
            flexDirection: 'row',
            gap: 20,
            marginBottom: 30
          },
          children: [
            Pressable({
              onPress: () => this.onAction?.('attack'),
              style: {
                backgroundColor: COLORS.error,
                borderRadius: 8,
                padding: 15,
                minWidth: 120
              },
              children: Text({
                content: '‚öîÔ∏è Attack',
                style: {
                  fontSize: DIMENSIONS.fontSize.lg,
                  fontWeight: 'bold',
                  color: '#fff',
                  textAlign: 'center'
                }
              })
            }),
            Pressable({
              onPress: () => this.onAction?.('defend'),
              style: {
                backgroundColor: COLORS.info,
                borderRadius: 8,
                padding: 15,
                minWidth: 120
              },
              children: Text({
                content: 'üõ°Ô∏è Defend',
                style: {
                  fontSize: DIMENSIONS.fontSize.lg,
                  fontWeight: 'bold',
                  color: '#fff',
                  textAlign: 'center'
                }
              })
            }),
            Pressable({
              onPress: () => this.onAction?.('special'),
              style: {
                backgroundColor: COLORS.warning,
                borderRadius: 8,
                padding: 15,
                minWidth: 120
              },
              children: Text({
                content: '‚ú® Special',
                style: {
                  fontSize: DIMENSIONS.fontSize.lg,
                  fontWeight: 'bold',
                  color: '#fff',
                  textAlign: 'center'
                }
              })
            })
          ]
        }),

        // Back button
        Pressable({
          onPress: () => this.onNavigate?.('menu'),
          style: {
            backgroundColor: COLORS.surface,
            borderRadius: 8,
            padding: 12
          },
          children: Text({
            content: '‚Üê Exit Battle',
            style: {
              fontSize: DIMENSIONS.fontSize.md,
              color: COLORS.textSecondary
            }
          })
        })
      ]
    });
  }

  /**
   * Create loading state placeholder
   */
  private createLoadingState(): UINodeType {
    return View({
      style: {
        width: '100%',
        height: '100%',
        backgroundColor: COLORS.background,
        justifyContent: 'center',
        alignItems: 'center',
      },
      children: Text({
        content: 'Loading Battle...',
        style: {
          fontSize: DIMENSIONS.fontSize.xl,
          color: COLORS.textPrimary,
        },
      }),
    });
  }

  /**
   * Create full-screen background
   */
  private createBackground(): UINodeType {
    return Image({
      source: new Binding({ uri: 'background' }),
      style: {
        position: 'absolute',
        width: gameDimensions.panelWidth,
        height: gameDimensions.panelHeight,
        top: 0,
        left: 0,
      },
    });
  }

  /**
   * Create playboard overlay image
   */
  private createPlayboard(): UINodeType {
    return Image({
      source: new Binding({ uri: 'playboard' }),
      style: {
        position: 'absolute',
        width: 1073,
        height: 572,
        left: playboardImagePositions.x,
        top: playboardImagePositions.y,
      },
    });
  }

  /**
   * Create all battle zones (beasts, traps, buffs, habitat)
   */
  private createBattleZones(state: BattleDisplay): UINodeType {
    return View({
      style: {
        position: 'absolute',
        width: '100%',
        height: '100%',
      },
      children: [
        // Player battlefield (bottom)
        ...this.createBeastField('player', state.playerField, state),

        // Opponent battlefield (top)
        ...this.createBeastField('opponent', state.opponentField, state),

        // Player trap zone
        ...this.createTrapZone('player', state.playerTrapZone),

        // Opponent trap zone
        ...this.createTrapZone('opponent', state.opponentTrapZone),

        // Player buff zone
        ...this.createBuffZone('player', state.playerBuffZone),

        // Opponent buff zone
        ...this.createBuffZone('opponent', state.opponentBuffZone),

        // Habitat zone (center)
        state.habitatZone ? this.createHabitatZone(state.habitatZone) : null,
      ].filter(Boolean),
    });
  }

  /**
   * Create beast field for a player
   */
  private createBeastField(
    player: 'player' | 'opponent',
    beasts: any[],
    state: BattleDisplay
  ): UINodeType[] {
    const positions = player === 'player'
      ? battleBoardAssetPositions.playerTwo
      : battleBoardAssetPositions.playerOne;
    const slots = [positions.beastOne, positions.beastTwo, positions.beastThree];

    return beasts.map((beast, index) => {
      if (!beast || !slots[index]) return null;

      const pos = slots[index];
      const isSelected = player === 'player' && state.selectedBeastIndex === index;
      const isAttacking = state.attackAnimation?.attackerPlayer === player &&
                         state.attackAnimation?.attackerIndex === index;
      const isTarget = state.attackAnimation?.targetPlayer === player &&
                      state.attackAnimation?.targetIndex === index;

      return View({
        key: `${player}-beast-${index}`,
        style: {
          position: 'absolute',
          left: pos.x,
          top: pos.y,
          width: standardCardDimensions.width,
          height: standardCardDimensions.height,
        },
        children: [
          // Beast card component
          createCardComponent({
            card: { ...beast, type: 'Bloom' },
            onClick: (cardId) => {
              if (player === 'player') {
                this.onAction?.(`select-beast-${index}`);
              } else if (state.selectedBeastIndex !== null) {
                this.onAction?.(`action-attack-${state.selectedBeastIndex}-${index}`);
              }
              this.onAction?.(`view-field-card-${player}-${index}`);
            },
          }),

          // Selection highlight
          isSelected ? View({
            style: {
              position: 'absolute',
              top: -5,
              left: -5,
              right: -5,
              bottom: -5,
              borderWidth: 5,
              borderColor: '#FFD700',
              borderRadius: 12,
              pointerEvents: 'none',
            },
          }) : null,

          // Attack animation overlay
          (isAttacking || isTarget) ? View({
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: isAttacking ? 'rgba(0, 255, 0, 0.4)' : 'rgba(255, 0, 0, 0.4)',
              borderRadius: 12,
              pointerEvents: 'none',
            },
          }) : null,

          // Action icons overlay
          this.createBeastActionIcons(beast, pos),
        ].filter(Boolean),
      });
    }).filter(Boolean);
  }

  /**
   * Create action icons for beast cards
   */
  private createBeastActionIcons(beast: any, pos: { x: number; y: number }): UINodeType | null {
    if (!beast.summoningSickness) {
      return View({
        style: {
          position: 'absolute',
          left: 17,
          top: 44,
          width: 26,
          height: 26,
        },
        children: Image({
          source: new Binding({ uri: 'attackIcon' }),
          style: { width: 26, height: 26 },
        }),
      });
    }
    return null;
  }

  /**
   * Create trap zone for a player
   */
  private createTrapZone(player: 'player' | 'opponent', traps: any[]): UINodeType[] {
    const positions = player === 'player'
      ? battleBoardAssetPositions.playerTwo
      : battleBoardAssetPositions.playerOne;
    const trapSlots = [positions.trapOne, positions.trapTwo, positions.trapThree];

    return traps.map((trap, index) => {
      if (!trap || !trapSlots[index]) return null;

      const pos = trapSlots[index];

      return View({
        key: `${player}-trap-${index}`,
        style: {
          position: 'absolute',
          left: pos.x,
          top: pos.y,
          width: trapCardDimensions.width,
          height: trapCardDimensions.height,
        },
        children: [
          // Trap card back (face-down)
          Image({
            source: new Binding({ uri: 'TrapCardPlayboard' }),
            style: {
              width: trapCardDimensions.width,
              height: trapCardDimensions.height,
            },
          }),

          // Click handler for player's traps only
          player === 'player' ? Pressable({
            onPress: () => this.onAction?.(`view-trap-card-${player}-${index}`),
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
            },
            children: null,
          }) : null,
        ].filter(Boolean),
      });
    }).filter(Boolean);
  }

  /**
   * Create buff zone for a player
   */
  private createBuffZone(player: 'player' | 'opponent', buffs: any[]): UINodeType[] {
    const positions = player === 'player'
      ? battleBoardAssetPositions.playerTwo
      : battleBoardAssetPositions.playerOne;
    const buffSlots = [positions.buffOne, positions.buffTwo];

    return buffs.map((buff, index) => {
      if (!buff || !buffSlots[index]) return null;

      const pos = buffSlots[index];

      return View({
        key: `${player}-buff-${index}`,
        style: {
          position: 'absolute',
          left: pos.x,
          top: pos.y,
          width: buffCardDimensions.width,
          height: buffCardDimensions.height,
        },
        children: [
          // Buff card component (face-up)
          createCardComponent({
            card: { ...buff, type: 'Buff' },
            onClick: () => this.onAction?.(`view-buff-card-${player}-${index}`),
          }),

          // Golden glow effect for active buffs
          View({
            style: {
              position: 'absolute',
              top: -3,
              left: -3,
              right: -3,
              bottom: -3,
              borderWidth: 3,
              borderColor: '#FFD700',
              borderRadius: 8,
              shadowColor: '#FFD700',
              shadowBlur: 8,
              pointerEvents: 'none',
            },
          }),
        ],
      });
    }).filter(Boolean);
  }

  /**
   * Create habitat zone
   */
  private createHabitatZone(habitat: any): UINodeType {
    const pos = battleBoardAssetPositions.habitatZone;

    return View({
      style: {
        position: 'absolute',
        left: pos.x,
        top: pos.y,
        width: habitatShiftCardDimensions.width,
        height: habitatShiftCardDimensions.height,
      },
      children: [
        // Habitat card
        createCardComponent({
          card: { ...habitat, type: 'Habitat' },
          onClick: () => this.onAction?.('view-habitat-card'),
        }),

        // Green glow effect for active habitat
        View({
          style: {
            position: 'absolute',
            top: -4,
            left: -4,
            right: -4,
            bottom: -4,
            borderWidth: 4,
            borderColor: '#4caf50',
            borderRadius: 8,
            shadowColor: '#4caf50',
            shadowBlur: 10,
            pointerEvents: 'none',
          },
        }),

        // Counter badges
        habitat.counters && habitat.counters.length > 0
          ? this.createCounterBadges(habitat.counters, pos)
          : null,
      ].filter(Boolean),
    });
  }

  /**
   * Create counter badges for habitat
   */
  private createCounterBadges(counters: any[], basePos: { x: number; y: number }): UINodeType {
    const counterMap = new Map<string, number>();
    counters.forEach((counter: any) => {
      const current = counterMap.get(counter.type) || 0;
      counterMap.set(counter.type, current + counter.amount);
    });

    const counterConfigs: Record<string, { emoji: string; color: string }> = {
      'Spore': { emoji: 'üçÑ', color: '#51cf66' },
    };

    const badges = Array.from(counterMap.entries()).map(([type, amount], index) => {
      if (amount <= 0) return null;

      const config = counterConfigs[type] || { emoji: '‚óè', color: '#868e96' };
      const badgeSize = 28;
      const badgeSpacing = 32;
      const offsetX = habitatShiftCardDimensions.width - 10 - (index * badgeSpacing);

      return View({
        key: `counter-${type}`,
        style: {
          position: 'absolute',
          right: 10 + (index * badgeSpacing),
          top: 5,
          width: badgeSize,
          height: badgeSize,
          backgroundColor: config.color,
          borderRadius: badgeSize / 2,
          borderWidth: 2,
          borderColor: '#fff',
          justifyContent: 'center',
          alignItems: 'center',
        },
        children: Text({
          content: `${config.emoji} ${amount}`,
          style: {
            fontSize: 16,
            fontWeight: 'bold',
            color: '#fff',
            textAlign: 'center',
          },
        }),
      });
    }).filter(Boolean);

    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: 'none',
      },
      children: badges,
    });
  }

  /**
   * Create player and opponent info displays
   */
  private createInfoDisplays(state: BattleDisplay): UINodeType {
    const opponentHealthPos = battleBoardAssetPositions.playerOne.health;
    const playerHealthPos = battleBoardAssetPositions.playerTwo.health;
    const opponentInfoPos = battleBoardAssetPositions.playOneInfoPosition;
    const playerInfoPos = battleBoardAssetPositions.playerTwoInfoPosition;

    const isOpponentHealthTarget = state.attackAnimation?.targetPlayer === 'health' &&
                                   state.attackAnimation?.attackerPlayer === 'player';
    const isPlayerHealthTarget = state.attackAnimation?.targetPlayer === 'health' &&
                                state.attackAnimation?.attackerPlayer === 'opponent';

    return View({
      style: {
        position: 'absolute',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
      },
      children: [
        // Opponent health
        View({
          style: {
            position: 'absolute',
            left: opponentHealthPos.x - 40,
            top: opponentHealthPos.y - 15,
            width: 80,
            height: 30,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: isOpponentHealthTarget ? 'rgba(255, 0, 0, 0.4)' : 'transparent',
            borderRadius: 4,
          },
          children: [
            Text({
              content: `${state.opponentHealth}/${state.opponentMaxHealth}`,
              style: {
                fontSize: 20,
                fontWeight: 'bold',
                color: '#fff',
                textAlign: 'center',
              },
            }),
            // Make clickable if a beast is selected
            state.selectedBeastIndex !== null ? Pressable({
              onPress: () => this.onAction?.(`action-attack-player-${state.selectedBeastIndex}`),
              style: {
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                pointerEvents: 'auto',
              },
              children: null,
            }) : null,
          ].filter(Boolean),
        }),

        // Player health
        View({
          style: {
            position: 'absolute',
            left: playerHealthPos.x - 40,
            top: playerHealthPos.y - 15,
            width: 80,
            height: 30,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: isPlayerHealthTarget ? 'rgba(255, 0, 0, 0.4)' : 'transparent',
            borderRadius: 4,
          },
          children: Text({
            content: `${state.playerHealth}/${state.playerMaxHealth}`,
            style: {
              fontSize: 20,
              fontWeight: 'bold',
              color: '#fff',
              textAlign: 'center',
            },
          }),
        }),

        // Opponent info
        View({
          style: {
            position: 'absolute',
            left: opponentInfoPos.x,
            top: opponentInfoPos.y,
          },
          children: [
            Text({
              content: 'Opponent',
              style: {
                fontSize: 20,
                fontWeight: 'bold',
                color: '#fff',
                marginBottom: 5,
              },
            }),
            Text({
              content: `${nectarEmoji} ${state.opponentNectar}/10`,
              style: {
                fontSize: 18,
                color: '#fff',
                marginBottom: 5,
              },
            }),
            Text({
              content: `${deckEmoji} ${state.opponentDeckCount}/30`,
              style: {
                fontSize: 18,
                color: '#fff',
              },
            }),
          ],
        }),

        // Player info
        View({
          style: {
            position: 'absolute',
            left: playerInfoPos.x,
            top: playerInfoPos.y,
          },
          children: [
            Text({
              content: 'Player',
              style: {
                fontSize: 20,
                fontWeight: 'bold',
                color: '#fff',
                marginBottom: 5,
              },
            }),
            Text({
              content: `${nectarEmoji} ${state.playerNectar}/10`,
              style: {
                fontSize: 18,
                color: '#fff',
                marginBottom: 5,
              },
            }),
            Text({
              content: `${deckEmoji} ${state.playerDeckCount}/30`,
              style: {
                fontSize: 18,
                color: '#fff',
              },
            }),
          ],
        }),
      ],
    });
  }

  /**
   * Create battle-specific side menu
   */
  private createBattleSideMenu(state: BattleDisplay): UINodeType {
    const isPlayerTurn = state.turnPlayer === 'player';
    const timerValue = this.turnTimer.get();
    const showDeathmatch = state.currentTurn >= 30;
    const deathmatchDamage = Math.floor((state.currentTurn - 30) / 5) + 1;

    return View({
      style: {
        position: 'absolute',
        left: sideMenuPositions.x,
        top: sideMenuPositions.y,
        width: 127,
        height: 465,
      },
      children: [
        // Side menu background
        Image({
          source: new Binding({ uri: 'sideMenu' }),
          style: {
            position: 'absolute',
            width: 127,
            height: 465,
          },
        }),

        // Forfeit button (at header position)
        Pressable({
          onPress: () => this.onAction?.('btn-back'),
          style: {
            position: 'absolute',
            left: sideMenuPositions.headerStartPosition.x - sideMenuPositions.x,
            top: sideMenuPositions.headerStartPosition.y - sideMenuPositions.y,
            width: sideMenuButtonDimensions.width,
            height: sideMenuButtonDimensions.height,
          },
          children: Image({
            source: new Binding({ uri: 'standardButton' }),
            style: {
              position: 'absolute',
              width: sideMenuButtonDimensions.width,
              height: sideMenuButtonDimensions.height,
            },
            children: Text({
              content: 'Forfeit',
              style: {
                fontSize: DIMENSIONS.fontSize.md,
                fontWeight: 'bold',
                color: '#fff',
                textAlign: 'center',
                lineHeight: sideMenuButtonDimensions.height,
              },
            }),
          }),
        }),

        // Battle info text
        View({
          style: {
            position: 'absolute',
            left: sideMenuPositions.textStartPosition.x - sideMenuPositions.x,
            top: sideMenuPositions.textStartPosition.y - sideMenuPositions.y,
          },
          children: [
            Text({
              content: 'Battle',
              style: {
                fontSize: 20,
                fontWeight: 'bold',
                color: '#fff',
                marginBottom: 5,
              },
            }),
            Text({
              content: `Turn ${state.currentTurn}`,
              style: {
                fontSize: 18,
                color: '#fff',
                marginBottom: 5,
              },
            }),
            showDeathmatch ? Text({
              content: `Deathmatch! -${deathmatchDamage} HP`,
              style: {
                fontSize: 16,
                color: '#ff6b6b',
                fontWeight: 'bold',
              },
            }) : null,
          ].filter(Boolean),
        }),

        // End Turn button with timer
        Pressable({
          onPress: isPlayerTurn ? () => {
            this.stopTurnTimer();
            this.onAction?.('btn-end-turn');
          } : undefined,
          disabled: !isPlayerTurn,
          style: {
            position: 'absolute',
            left: sideMenuPositions.buttonStartPosition.x - sideMenuPositions.x,
            top: sideMenuPositions.buttonStartPosition.y - sideMenuPositions.y,
            width: sideMenuButtonDimensions.width,
            height: sideMenuButtonDimensions.height,
            opacity: isPlayerTurn ? 1 : 0.5,
          },
          children: Image({
            source: new Binding({ uri: isPlayerTurn ? 'greenButton' : 'standardButton' }),
            style: {
              position: 'absolute',
              width: sideMenuButtonDimensions.width,
              height: sideMenuButtonDimensions.height,
            },
            children: Text({
              content: isPlayerTurn ? `(${timerValue})` : 'End Turn',
              style: {
                fontSize: DIMENSIONS.fontSize.md,
                fontWeight: 'bold',
                color: '#fff',
                textAlign: 'center',
                lineHeight: sideMenuButtonDimensions.height,
              },
            }),
          }),
        }),
      ],
    });
  }

  /**
   * Create player hand overlay
   */
  private createPlayerHand(state: BattleDisplay): UINodeType | null {
    if (!state.playerHand || state.playerHand.length === 0) return null;

    const showFull = this.showHand.get();
    const scrollOffset = this.handScrollOffset.get();
    const overlayHeight = showFull ? 280 : 40;
    const cardWidth = 128; // Scaled down from standard card
    const cardHeight = 170;
    const cardGap = 8;
    const cardsPerPage = 5;
    const totalPages = Math.ceil(state.playerHand.length / cardsPerPage);

    // Calculate visible cards
    const startIndex = scrollOffset * cardsPerPage;
    const endIndex = Math.min(startIndex + cardsPerPage, state.playerHand.length);
    const visibleCards = state.playerHand.slice(startIndex, endIndex);

    return View({
      style: {
        position: 'absolute',
        left: 0,
        bottom: 0,
        width: gameDimensions.panelWidth,
        height: overlayHeight,
        backgroundColor: 'rgba(0, 0, 0, 0.85)',
        borderTopWidth: 2,
        borderColor: '#4a8ec2',
      },
      children: [
        // Toggle button (always visible, positioned at top-right)
        Pressable({
          onPress: () => this.showHand.set(!showFull),
          style: {
            position: 'absolute',
            right: 15,
            top: 8,
            width: 50,
            height: 24,
            backgroundColor: '#4a8ec2',
            borderRadius: 4,
            justifyContent: 'center',
            alignItems: 'center',
          },
          children: Text({
            text: showFull ? '‚ñº Hide' : '‚ñ≤ Show',
            style: {
              fontSize: 12,
              fontWeight: 'bold',
              color: '#fff',
            },
          }),
        }),

        // Cards row (only when expanded)
        showFull ? View({
          style: {
            position: 'absolute',
            left: 20,
            top: 40,
            flexDirection: 'row',
            gap: cardGap,
          },
          children: visibleCards.map((card, i) => {
            const actualIndex = startIndex + i;
            const canAfford = card.cost <= state.playerNectar;

            return View({
              key: `hand-card-${actualIndex}`,
              style: {
                position: 'relative',
                width: cardWidth,
                height: cardHeight,
                opacity: canAfford ? 1 : 0.6,
              },
              children: [
                createCardComponent({
                  card: card,
                  size: 'small', // Use smaller size for hand
                  onClick: () => this.onAction?.(`view-hand-card-${actualIndex}`),
                }),

                // Affordability highlight
                canAfford ? View({
                  style: {
                    position: 'absolute',
                    top: -3,
                    left: -3,
                    right: -3,
                    bottom: -3,
                    borderWidth: 3,
                    borderColor: '#43e97b',
                    borderRadius: 8,
                    pointerEvents: 'none',
                  },
                }) : null,
              ].filter(Boolean),
            });
          }),
        }) : null,

        // Scroll buttons (only when expanded and multiple pages)
        showFull && totalPages > 1 ? View({
          style: {
            position: 'absolute',
            right: 15,
            top: 40,
            flexDirection: 'column',
            gap: 8,
          },
          children: [
            // Left/Up button
            Pressable({
              onPress: () => {
                const newOffset = Math.max(0, scrollOffset - 1);
                this.handScrollOffset.set(newOffset);
              },
              disabled: scrollOffset <= 0,
              style: {
                width: 50,
                height: 50,
                backgroundColor: scrollOffset > 0 ? '#4a8ec2' : '#333',
                borderRadius: 8,
                justifyContent: 'center',
                alignItems: 'center',
                opacity: scrollOffset > 0 ? 1 : 0.5,
              },
              children: Text({
                text: '‚óÄ',
                style: {
                  fontSize: 20,
                  fontWeight: 'bold',
                  color: '#fff',
                },
              }),
            }),

            // Right/Down button
            Pressable({
              onPress: () => {
                const newOffset = Math.min(totalPages - 1, scrollOffset + 1);
                this.handScrollOffset.set(newOffset);
              },
              disabled: scrollOffset >= totalPages - 1,
              style: {
                width: 50,
                height: 50,
                backgroundColor: scrollOffset < totalPages - 1 ? '#4a8ec2' : '#333',
                borderRadius: 8,
                justifyContent: 'center',
                alignItems: 'center',
                opacity: scrollOffset < totalPages - 1 ? 1 : 0.5,
              },
              children: Text({
                text: '‚ñ∂',
                style: {
                  fontSize: 20,
                  fontWeight: 'bold',
                  color: '#fff',
                },
              }),
            }),
          ],
        }) : null,

        // Card count indicator (only when collapsed)
        !showFull ? View({
          style: {
            position: 'absolute',
            left: 20,
            top: 10,
          },
          children: Text({
            text: `Hand: ${state.playerHand.length} cards`,
            style: {
              fontSize: 14,
              color: '#fff',
            },
          }),
        }) : null,
      ].filter(Boolean),
    });
  }

  /**
   * Create card popup overlay
   */
  private createCardPopup(popup: any): UINodeType {
    return View({
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
      },
      children: [
        // Card detail popup
        createCardDetailPopup({
          card: popup.card,
          onClose: popup.showCloseButton ? () => this.onAction?.('btn-card-close') : undefined,
        }),
      ],
    });
  }

  /**
   * Create attack animation overlays
   */
  private createAttackAnimations(state: BattleDisplay): UINodeType | null {
    // Attack animations are handled directly in the beast field rendering
    // This is a placeholder for any additional animation effects
    return null;
  }

  /**
   * Start the turn timer
   */
  private startTurnTimer(): void {
    this.turnTimer.set(60);
    this.timerInterval = setInterval(() => {
      const current = this.turnTimer.get();
      if (current <= 0) {
        this.stopTurnTimer();
        this.onAction?.('btn-end-turn');
      } else {
        this.turnTimer.set(current - 1);
        this.onRenderNeeded?.();
      }
    }, 1000);
  }

  /**
   * Stop the turn timer
   */
  private stopTurnTimer(): void {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }

  /**
   * Cleanup resources
   */
  public cleanup(): void {
    this.stopTurnTimer();
    this.showHand.set(true);
    this.handScrollOffset.set(0);
    this.selectedCardDetail.set(null);
  }
}